GC::malloc(gcx = 002CF6C8, size = 120 bits = 1, ti = core.thread.Thread)
Setting a pointer bitmap for core.thread.Thread at 01C00F80 + 120
	Setting bitmap for new object (core.thread.Thread)
		at 01C00F80		copying from 0044A784 + 120: 001000110001111111010000000011
	malloc => 01C00F80
GC.addRange_hp(0045A760 - 0045AA20, tls=0)
GC.addRange_hp(0045AACC - 0045AB1C, tls=1)
GC::malloc(gcx = 002CF6C8, size = 11 bits = 4a, ti = TypeInfo_a)
	malloc => 01C01FF0
GC::malloc(gcx = 002CF6C8, size = 31 bits = 4a, ti = TypeInfo_a)
	malloc => 01C02FE0
GC::malloc(gcx = 002CF6C8, size = 58 bits = 4a, ti = TypeInfo_a)
	malloc => 01C03FC0
GC::malloc(gcx = 002CF6C8, size = 59 bits = 4a, ti = TypeInfo_a)
	malloc => 01C03F80
GC::malloc(gcx = 002CF6C8, size = 522 bits = 4a, ti = TypeInfo_u)
	malloc => 01C04C00
GC::malloc(gcx = 002CF6C8, size = 12 bits = 0, ti = std.array.Appender!string.Appender.Data)
Setting a pointer bitmap for std.array.Appender!string.Appender.Data at 01C01FE0 + 12
	Setting bitmap for new object (std.array.Appender!string.Appender.Data)
		at 01C01FE0		copying from 00441FE4 + 12: 001
	malloc => 01C01FE0
GC::malloc(gcx = 002CF6C8, size = 8 bits = 2, ti = null)
	malloc => 01C01FD0
GC::malloc(gcx = 002CF6C8, size = 32 bits = 2, ti = null)
	malloc => 01C02FC0
GC::malloc(gcx = 002CF6C8, size = 64 bits = 2, ti = null)
	malloc => 01C03F40
GC::malloc(gcx = 002CF6C8, size = 128 bits = 2, ti = null)
	malloc => 01C00F00
GC::malloc(gcx = 002CF6C8, size = 256 bits = 2, ti = null)
	malloc => 01C05F00
GC::malloc(gcx = 002CF6C8, size = 512 bits = 2, ti = null)
	malloc => 01C06E00
GC::malloc(gcx = 002CF6C8, size = 1024 bits = 2, ti = null)
	malloc => 01C04800
GC::malloc(gcx = 002CF6C8, size = 48 bits = 4a, ti = TypeInfo_a)
	malloc => 01C03F00
GC::malloc(gcx = 002CF6C8, size = 12 bits = 0, ti = std.array.Appender!(immutable(wchar)[]).Appender.Data)
Setting a pointer bitmap for std.array.Appender!(immutable(wchar)[]).Appender.Data at 01C01FC0 + 12
	Setting bitmap for new object (std.array.Appender!(immutable(wchar)[]).Appender.Data)
		at 01C01FC0		copying from 00442084 + 12: 001
	malloc => 01C01FC0
GC::malloc(gcx = 002CF6C8, size = 16 bits = 2, ti = null)
	malloc => 01C01FB0
GC::malloc(gcx = 002CF6C8, size = 32 bits = 2, ti = null)
	malloc => 01C02FA0
GC::malloc(gcx = 002CF6C8, size = 64 bits = 2, ti = null)
	malloc => 01C03EC0
GC::malloc(gcx = 002CF6C8, size = 128 bits = 2, ti = null)
	malloc => 01C00E80
GC::malloc(gcx = 002CF6C8, size = 95 bits = 4a, ti = TypeInfo_u)
	malloc => 01C00E00
GC::malloc(gcx = 002CF6C8, size = 21 bits = 4a, ti = TypeInfo_a)
	malloc => 01C02F80
GC::malloc(gcx = 002CF6C8, size = 2065 bits = 2a, ti = TypeInfo_a)
In bigAlloc.  Size:  2065
Gcx.fullcollect()
Set bits
Marked free entries.
	scan stacks.
marking tls range from 0018F8AC to 00190000
		@0018FA00 -> 01C02F80: mark(x2f8) = 0
		@0018FAC0 -> 01C02F80: mark(x2f8) = 16777216
		@0018FB08 -> 01C02F80: mark(x2f8) = 16777216
		@0018FB10 -> 01C02F80: mark(x2f8) = 16777216
		@0018FBA4 -> 01C03F80: mark(x3f8) = 0
		@0018FBAC -> 01C04800: mark(x480) = 0
		@0018FBBC -> 01C00E00: mark(xe0) = 0
		@0018FC38 -> 01C03FC0: mark(x3fc) = 0
		@0018FCB4 -> 01C03F80: mark(x3f8) = 16777216
marking tls range from 01C00FD0 to 01C00FF0
		@01C00FD4 -> 01C00F80: mark(xf8) = 0
not skipping 01C00FB0, biti = 1009, at 01C00FC4
		@01C00FC4 -> 01C00FB0: mark(xf8) = 16777216
marking tls hp range from 0045AACC to 0045AB1C, base 002C35B0
Mark call for 1 002C35C0 with type info TypeInfo_AssociativeArray: rtInfo: has 1 pointers
Mark call for 1 002C35D0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 002C35E0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 002C35F0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 002C35F4 with type info core.thread.Thread: class reference
		@002C35F4 -> 01C00F80: mark(xf8) = 16777216
Mark call for 1 002C3610 with type info core.thread.Fiber: class reference
Mark call for 1 002C3620 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 002C3624 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 002C3628 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 002C3630 with type info std.file.DirIteratorImpl: mark with rtInfo
	scan roots[]
	scan ranges[]
	mark hasPointer area
marking hp range from 0045A760 to 0045AA20
Mark call for 1 00441C60 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00441D60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DD0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441ED0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00442100 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442104 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442108 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044210C with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442110 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ABD0 with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABDC with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABE8 with type info std.stdio.File: mark with rtInfo
Mark call for 1 00443200 with type info TypeInfo_StaticArray: rtInfo: has 46 pointers
Mark call for 1 0045AC10 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC30 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AC40 with type info rt.dmain2.CArgs: mark with rtInfo
Mark call for 1 0045AC50 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC60 with type info gc.gc.GC: class reference
Mark call for 1 0045AC70 with type info gc.proxy.Proxy: mark with rtInfo
Mark call for 1 0045ACCC with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ACD0 with type info rt.sections_win32.SectionGroup: mark with rtInfo
Mark call for 1 0045AD00 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AD14 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00446028 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00446110 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 004461F0 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446280 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446460 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0044646C with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 00446478 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0045AD54 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD58 with type info gc.gc.GCMutex: class reference
Mark call for 1 0045AD90 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD94 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADB0 with type info rt.critical_.D_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE40 with type info core.sys.windows.windows._RTL_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE6C with type info core.thread.Thread: class reference
		@0045AE6C -> 01C00F80: mark(xf8) = 16777216
Mark call for 1 0045AEC0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
		@0045AEC0 -> 01C00FB0: mark(xf8) = 16777216
Mark call for 1 0045AEC8 with type info core.thread.Thread: class reference
		@0045AEC8 -> 01C00F80: mark(xf8) = 16777216
Mark call for 1 0045AEE0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00448320 with type info std.datetime.UTC: rtInfo: has 1 pointers
Mark call for 1 00448A90 with type info std.datetime.LocalTime: rtInfo: has 1 pointers
Mark call for 1 0045AFA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B130 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044B1A0 with type info TypeInfo_StaticArray: mark with rtInfo
Mark call for 1 0045B180 with type info core.sys.windows.dbghelp.DbgHelp: mark with rtInfo
Mark call for 1 0045B1C0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B2A0 with type info TypeInfo_Aya: mark with rtInfo
Mark call for 1 0044F870 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00450660 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00452730 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00453B30 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 0045C7D0 with type info std.file.DirIteratorImpl: rtInfo: has 22 pointers
Mark call for 1 00456810 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00457A20 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00458C30 with type info std.uni.Trie!(BitPacked!(bool, 1), dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(8u, 13u), sliceBits!(0u, 8u)).Trie: rtInfo: has 8 pointers
	scan heap
	free'ing
	collecting 01C00E80
	collecting 01C00F00
	collecting 01C01FB0
	collecting 01C01FC0
	collecting 01C01FD0
	collecting 01C01FE0
	collecting 01C01FF0
	collecting 01C02FA0
	collecting 01C02FC0
	collecting 01C02FE0
	collecting 01C03EC0
	collecting 01C03F00
	collecting 01C03F40
	collecting 01C04C00
	collecting 01C05F00
	collecting 01C06E00
	free complete pages
	recovered pages = 3
	free'd 2416 bytes, 0 pages from 1 pools
Minimizing.
Done minimizing.
Pool 0038D888:  256 really free, 256 supposedly free
Pool 0038D888:  255 really free, 255 supposedly free
Got large alloc:  01D00000, pt = 8, np = 1
	malloc => 01D00000
Emplacing TypeInfo_a at 01D00010 + 4080
Setting a pointer bitmap for TypeInfo_a at 01D00010 + 4080
	Compiler generated rtInfo: no pointers
Gcx.fullcollect()
Set bits
Marked free entries.
	scan roots[]
	scan ranges[]
	mark hasPointer area
marking hp range from 0045A760 to 0045AA20
Mark call for 1 00441C60 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00441D60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DD0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441ED0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00442100 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442104 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442108 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044210C with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442110 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ABD0 with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABDC with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABE8 with type info std.stdio.File: mark with rtInfo
Mark call for 1 00443200 with type info TypeInfo_StaticArray: rtInfo: has 46 pointers
Mark call for 1 0045AC10 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC30 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AC40 with type info rt.dmain2.CArgs: mark with rtInfo
Mark call for 1 0045AC50 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC60 with type info gc.gc.GC: class reference
Mark call for 1 0045AC70 with type info gc.proxy.Proxy: mark with rtInfo
Mark call for 1 0045ACCC with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ACD0 with type info rt.sections_win32.SectionGroup: mark with rtInfo
Mark call for 1 0045AD00 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AD14 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00446028 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00446110 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 004461F0 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446280 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446460 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0044646C with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 00446478 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0045AD54 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD58 with type info gc.gc.GCMutex: class reference
Mark call for 1 0045AD90 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD94 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADB0 with type info rt.critical_.D_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE40 with type info core.sys.windows.windows._RTL_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE6C with type info core.thread.Thread: class reference
		@0045AE6C -> 01C00F80: mark(xf8) = 0
not skipping 01C00FB0, biti = 1009, at 01C00FC4
		@01C00FC4 -> 01C00FB0: mark(xf8) = 16777216
Mark call for 1 0045AEC0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
		@0045AEC0 -> 01C00FB0: mark(xf8) = 16777216
Mark call for 1 0045AEC8 with type info core.thread.Thread: class reference
		@0045AEC8 -> 01C00F80: mark(xf8) = 16777216
Mark call for 1 0045AEE0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00448320 with type info std.datetime.UTC: rtInfo: has 1 pointers
Mark call for 1 00448A90 with type info std.datetime.LocalTime: rtInfo: has 1 pointers
Mark call for 1 0045AFA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B130 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044B1A0 with type info TypeInfo_StaticArray: mark with rtInfo
Mark call for 1 0045B180 with type info core.sys.windows.dbghelp.DbgHelp: mark with rtInfo
Mark call for 1 0045B1C0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B2A0 with type info TypeInfo_Aya: mark with rtInfo
Mark call for 1 0044F870 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00450660 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00452730 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00453B30 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 0045C7D0 with type info std.file.DirIteratorImpl: rtInfo: has 22 pointers
Mark call for 1 00456810 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00457A20 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00458C30 with type info std.uni.Trie!(BitPacked!(bool, 1), dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(8u, 13u), sliceBits!(0u, 8u)).Trie: rtInfo: has 8 pointers
	scan heap
	free'ing
	collecting 01C00E00
	collecting 01C02F80
	collecting 01C03F80
	collecting 01C03FC0
	collecting 01C04800
	collecting big 01D00000
	free complete pages
	recovered pages = 3
	free'd 1312 bytes, 1 pages from 2 pools
