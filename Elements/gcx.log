GC::malloc(gcx = 005A64A8, size = 120 bits = 1, ti = core.thread.Thread)
Setting a pointer bitmap for core.thread.Thread at 00470F80 + 120
	Setting bitmap for new object (core.thread.Thread)
		at 00470F80		copying from 0044A784 + 120: 001000110001111111010000000011
	malloc => 00470F80
GC.addRange_hp(0045A760 - 0045AA20, tls=0)
GC.addRange_hp(0045AACC - 0045AB1C, tls=1)
GC::malloc(gcx = 005A64A8, size = 11 bits = 4a, ti = TypeInfo_a)
	malloc => 00471FF0
GC::malloc(gcx = 005A64A8, size = 31 bits = 4a, ti = TypeInfo_a)
	malloc => 00472FE0
GC::malloc(gcx = 005A64A8, size = 60 bits = 4a, ti = TypeInfo_a)
	malloc => 00473FC0
GC::malloc(gcx = 005A64A8, size = 61 bits = 4a, ti = TypeInfo_a)
	malloc => 00473F80
GC::malloc(gcx = 005A64A8, size = 522 bits = 4a, ti = TypeInfo_u)
	malloc => 00474C00
GC::malloc(gcx = 005A64A8, size = 12 bits = 0, ti = std.array.Appender!string.Appender.Data)
Setting a pointer bitmap for std.array.Appender!string.Appender.Data at 00471FE0 + 12
	Setting bitmap for new object (std.array.Appender!string.Appender.Data)
		at 00471FE0		copying from 00441FE4 + 12: 001
	malloc => 00471FE0
GC::malloc(gcx = 005A64A8, size = 8 bits = 2, ti = null)
	malloc => 00471FD0
GC::malloc(gcx = 005A64A8, size = 32 bits = 2, ti = null)
	malloc => 00472FC0
GC::malloc(gcx = 005A64A8, size = 64 bits = 2, ti = null)
	malloc => 00473F40
GC::malloc(gcx = 005A64A8, size = 128 bits = 2, ti = null)
	malloc => 00470F00
GC::malloc(gcx = 005A64A8, size = 256 bits = 2, ti = null)
	malloc => 00475F00
GC::malloc(gcx = 005A64A8, size = 512 bits = 2, ti = null)
	malloc => 00476E00
GC::malloc(gcx = 005A64A8, size = 1024 bits = 2, ti = null)
	malloc => 00474800
GC::malloc(gcx = 005A64A8, size = 48 bits = 4a, ti = TypeInfo_a)
	malloc => 00473F00
GC::malloc(gcx = 005A64A8, size = 12 bits = 0, ti = std.array.Appender!(immutable(wchar)[]).Appender.Data)
Setting a pointer bitmap for std.array.Appender!(immutable(wchar)[]).Appender.Data at 00471FC0 + 12
	Setting bitmap for new object (std.array.Appender!(immutable(wchar)[]).Appender.Data)
		at 00471FC0		copying from 00442084 + 12: 001
	malloc => 00471FC0
GC::malloc(gcx = 005A64A8, size = 16 bits = 2, ti = null)
	malloc => 00471FB0
GC::malloc(gcx = 005A64A8, size = 32 bits = 2, ti = null)
	malloc => 00472FA0
GC::malloc(gcx = 005A64A8, size = 64 bits = 2, ti = null)
	malloc => 00473EC0
GC::malloc(gcx = 005A64A8, size = 128 bits = 2, ti = null)
	malloc => 00470E80
GC::malloc(gcx = 005A64A8, size = 95 bits = 4a, ti = TypeInfo_u)
	malloc => 00470E00
GC::malloc(gcx = 005A64A8, size = 23 bits = 4a, ti = TypeInfo_a)
	malloc => 00472F80
GC::malloc(gcx = 005A64A8, size = 2065 bits = 2a, ti = TypeInfo_a)
In bigAlloc.  Size:  2065
Gcx.fullcollect()
Set bits
Marked free entries.
	scan stacks.
marking tls range from 0018F8A4 to 00190000
		@0018F9F8 -> 00472F80: mark(x2f8) = 0
		@0018FAB8 -> 00472F80: mark(x2f8) = 16777216
		@0018FB00 -> 00472F80: mark(x2f8) = 16777216
		@0018FB08 -> 00472F80: mark(x2f8) = 16777216
		@0018FB9C -> 00473F80: mark(x3f8) = 0
		@0018FBA4 -> 00474800: mark(x480) = 0
		@0018FBB4 -> 00470E00: mark(xe0) = 0
		@0018FC30 -> 00473FC0: mark(x3fc) = 0
		@0018FCAC -> 00473F80: mark(x3f8) = 16777216
marking tls range from 00470FD0 to 00470FF0
		@00470FD4 -> 00470F80: mark(xf8) = 0
not skipping 00470FB0, biti = 1009, at 00470FC4
		@00470FC4 -> 00470FB0: mark(xf8) = 16777216
marking tls hp range from 0045AACC to 0045AB1C, base 00593688
Mark call for 1 00593698 with type info TypeInfo_AssociativeArray: rtInfo: has 1 pointers
Mark call for 1 005936A8 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005936B8 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005936C8 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005936CC with type info core.thread.Thread: class reference
		@005936CC -> 00470F80: mark(xf8) = 16777216
Mark call for 1 005936E8 with type info core.thread.Fiber: class reference
Mark call for 1 005936F8 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005936FC with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00593700 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00593708 with type info std.file.DirIteratorImpl: mark with rtInfo
	scan roots[]
	scan ranges[]
	mark hasPointer area
marking hp range from 0045A760 to 0045AA20
Mark call for 1 00441C60 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00441D60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DD0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441ED0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00442100 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442104 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442108 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044210C with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442110 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ABD0 with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABDC with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABE8 with type info std.stdio.File: mark with rtInfo
Mark call for 1 00443200 with type info TypeInfo_StaticArray: rtInfo: has 46 pointers
Mark call for 1 0045AC10 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC30 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AC40 with type info rt.dmain2.CArgs: mark with rtInfo
Mark call for 1 0045AC50 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC60 with type info gc.gc.GC: class reference
Mark call for 1 0045AC70 with type info gc.proxy.Proxy: mark with rtInfo
Mark call for 1 0045ACCC with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ACD0 with type info rt.sections_win32.SectionGroup: mark with rtInfo
Mark call for 1 0045AD00 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AD14 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00446028 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00446110 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 004461F0 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446280 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446460 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0044646C with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 00446478 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0045AD54 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD58 with type info gc.gc.GCMutex: class reference
Mark call for 1 0045AD90 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD94 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADB0 with type info rt.critical_.D_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE40 with type info core.sys.windows.windows._RTL_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE6C with type info core.thread.Thread: class reference
		@0045AE6C -> 00470F80: mark(xf8) = 16777216
Mark call for 1 0045AEC0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
		@0045AEC0 -> 00470FB0: mark(xf8) = 16777216
Mark call for 1 0045AEC8 with type info core.thread.Thread: class reference
		@0045AEC8 -> 00470F80: mark(xf8) = 16777216
Mark call for 1 0045AEE0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00448320 with type info std.datetime.UTC: rtInfo: has 1 pointers
Mark call for 1 00448A90 with type info std.datetime.LocalTime: rtInfo: has 1 pointers
Mark call for 1 0045AFA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B130 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044B1A0 with type info TypeInfo_StaticArray: mark with rtInfo
Mark call for 1 0045B180 with type info core.sys.windows.dbghelp.DbgHelp: mark with rtInfo
Mark call for 1 0045B1C0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B2A0 with type info TypeInfo_Aya: mark with rtInfo
Mark call for 1 0044F870 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00450660 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00452730 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00453B30 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 0045C7D0 with type info std.file.DirIteratorImpl: rtInfo: has 22 pointers
Mark call for 1 00456810 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00457A20 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00458C30 with type info std.uni.Trie!(BitPacked!(bool, 1), dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(8u, 13u), sliceBits!(0u, 8u)).Trie: rtInfo: has 8 pointers
	scan heap
	free'ing
	collecting 00470E80
	collecting 00470F00
	collecting 00471FB0
	collecting 00471FC0
	collecting 00471FD0
	collecting 00471FE0
	collecting 00471FF0
	collecting 00472FA0
	collecting 00472FC0
	collecting 00472FE0
	collecting 00473EC0
	collecting 00473F00
	collecting 00473F40
	collecting 00474C00
	collecting 00475F00
	collecting 00476E00
	free complete pages
	recovered pages = 3
	free'd 2416 bytes, 0 pages from 1 pools
Minimizing.
Done minimizing.
Pool 00680418:  256 really free, 256 supposedly free
Pool 00680418:  255 really free, 255 supposedly free
Got large alloc:  021B0000, pt = 8, np = 1
	malloc => 021B0000
Emplacing TypeInfo_a at 021B0010 + 4080
Setting a pointer bitmap for TypeInfo_a at 021B0010 + 4080
	Compiler generated rtInfo: no pointers
Gcx.fullcollect()
Set bits
Marked free entries.
	scan roots[]
	scan ranges[]
	mark hasPointer area
marking hp range from 0045A760 to 0045AA20
Mark call for 1 00441C60 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00441D60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DD0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441ED0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00442100 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442104 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442108 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044210C with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442110 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ABD0 with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABDC with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABE8 with type info std.stdio.File: mark with rtInfo
Mark call for 1 00443200 with type info TypeInfo_StaticArray: rtInfo: has 46 pointers
Mark call for 1 0045AC10 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC30 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AC40 with type info rt.dmain2.CArgs: mark with rtInfo
not skipping 0059C5C8, biti = 1, at 0045AC44
Mark call for 1 0045AC50 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC60 with type info gc.gc.GC: class reference
Mark call for 1 0045AC70 with type info gc.proxy.Proxy: mark with rtInfo
Mark call for 1 0045ACCC with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ACD0 with type info rt.sections_win32.SectionGroup: mark with rtInfo
Mark call for 1 0045AD00 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AD14 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00446028 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00446110 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 004461F0 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446280 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446460 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0044646C with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 00446478 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0045AD54 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD58 with type info gc.gc.GCMutex: class reference
Mark call for 1 0045AD90 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD94 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADB0 with type info rt.critical_.D_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE40 with type info core.sys.windows.windows._RTL_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE6C with type info core.thread.Thread: class reference
		@0045AE6C -> 00470F80: mark(xf8) = 0
not skipping 00470FB0, biti = 1009, at 00470FC4
		@00470FC4 -> 00470FB0: mark(xf8) = 16777216
not skipping 005D1F98, biti = 1011, at 00470FCC
Mark call for 1 0045AEC0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
		@0045AEC0 -> 00470FB0: mark(xf8) = 16777216
Mark call for 1 0045AEC8 with type info core.thread.Thread: class reference
		@0045AEC8 -> 00470F80: mark(xf8) = 16777216
Mark call for 1 0045AEE0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00448320 with type info std.datetime.UTC: rtInfo: has 1 pointers
Mark call for 1 00448A90 with type info std.datetime.LocalTime: rtInfo: has 1 pointers
Mark call for 1 0045AFA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B130 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044B1A0 with type info TypeInfo_StaticArray: mark with rtInfo
Mark call for 1 0045B180 with type info core.sys.windows.dbghelp.DbgHelp: mark with rtInfo
Mark call for 1 0045B1C0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B2A0 with type info TypeInfo_Aya: mark with rtInfo
Mark call for 1 0044F870 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00450660 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00452730 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00453B30 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 0045C7D0 with type info std.file.DirIteratorImpl: rtInfo: has 22 pointers
Mark call for 1 00456810 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00457A20 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00458C30 with type info std.uni.Trie!(BitPacked!(bool, 1), dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(8u, 13u), sliceBits!(0u, 8u)).Trie: rtInfo: has 8 pointers
	scan heap
	free'ing
	collecting 00470E00
	collecting 00472F80
	collecting 00473F80
	collecting 00473FC0
	collecting 00474800
	collecting big 021B0000
	free complete pages
	recovered pages = 3
	free'd 1312 bytes, 1 pages from 2 pools
