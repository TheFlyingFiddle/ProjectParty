GC::malloc(gcx = 005F6968, size = 120 bits = 1, ti = core.thread.Thread)
Setting a pointer bitmap for core.thread.Thread at 004E0F80 + 120
	Setting bitmap for new object (core.thread.Thread)
		at 004E0F80		copying from 0044A784 + 120: 001000110001111111010000000011
	malloc => 004E0F80
GC.addRange_hp(0045A760 - 0045AA20, tls=0)
GC.addRange_hp(0045AACC - 0045AB1C, tls=1)
GC::malloc(gcx = 005F6968, size = 11 bits = 4a, ti = TypeInfo_a)
	malloc => 004E1FF0
GC::malloc(gcx = 005F6968, size = 31 bits = 4a, ti = TypeInfo_a)
	malloc => 004E2FE0
GC::malloc(gcx = 005F6968, size = 59 bits = 4a, ti = TypeInfo_a)
	malloc => 004E3FC0
GC::malloc(gcx = 005F6968, size = 60 bits = 4a, ti = TypeInfo_a)
	malloc => 004E3F80
GC::malloc(gcx = 005F6968, size = 522 bits = 4a, ti = TypeInfo_u)
	malloc => 004E4C00
GC::malloc(gcx = 005F6968, size = 12 bits = 0, ti = std.array.Appender!string.Appender.Data)
Setting a pointer bitmap for std.array.Appender!string.Appender.Data at 004E1FE0 + 12
	Setting bitmap for new object (std.array.Appender!string.Appender.Data)
		at 004E1FE0		copying from 00441FE4 + 12: 001
	malloc => 004E1FE0
GC::malloc(gcx = 005F6968, size = 8 bits = 2, ti = null)
	malloc => 004E1FD0
GC::malloc(gcx = 005F6968, size = 32 bits = 2, ti = null)
	malloc => 004E2FC0
GC::malloc(gcx = 005F6968, size = 64 bits = 2, ti = null)
	malloc => 004E3F40
GC::malloc(gcx = 005F6968, size = 128 bits = 2, ti = null)
	malloc => 004E0F00
GC::malloc(gcx = 005F6968, size = 256 bits = 2, ti = null)
	malloc => 004E5F00
GC::malloc(gcx = 005F6968, size = 512 bits = 2, ti = null)
	malloc => 004E6E00
GC::malloc(gcx = 005F6968, size = 1024 bits = 2, ti = null)
	malloc => 004E4800
GC::malloc(gcx = 005F6968, size = 48 bits = 4a, ti = TypeInfo_a)
	malloc => 004E3F00
GC::malloc(gcx = 005F6968, size = 12 bits = 0, ti = std.array.Appender!(immutable(wchar)[]).Appender.Data)
Setting a pointer bitmap for std.array.Appender!(immutable(wchar)[]).Appender.Data at 004E1FC0 + 12
	Setting bitmap for new object (std.array.Appender!(immutable(wchar)[]).Appender.Data)
		at 004E1FC0		copying from 00442084 + 12: 001
	malloc => 004E1FC0
GC::malloc(gcx = 005F6968, size = 16 bits = 2, ti = null)
	malloc => 004E1FB0
GC::malloc(gcx = 005F6968, size = 32 bits = 2, ti = null)
	malloc => 004E2FA0
GC::malloc(gcx = 005F6968, size = 64 bits = 2, ti = null)
	malloc => 004E3EC0
GC::malloc(gcx = 005F6968, size = 128 bits = 2, ti = null)
	malloc => 004E0E80
GC::malloc(gcx = 005F6968, size = 95 bits = 4a, ti = TypeInfo_u)
	malloc => 004E0E00
GC::malloc(gcx = 005F6968, size = 22 bits = 4a, ti = TypeInfo_a)
	malloc => 004E2F80
GC::malloc(gcx = 005F6968, size = 2065 bits = 2a, ti = TypeInfo_a)
In bigAlloc.  Size:  2065
Gcx.fullcollect()
Set bits
Marked free entries.
	scan stacks.
marking tls range from 0018F8AC to 00190000
		@0018FA00 -> 004E2F80: mark(x2f8) = 0
		@0018FAC0 -> 004E2F80: mark(x2f8) = 16777216
		@0018FB08 -> 004E2F80: mark(x2f8) = 16777216
		@0018FB10 -> 004E2F80: mark(x2f8) = 16777216
		@0018FBA4 -> 004E3F80: mark(x3f8) = 0
		@0018FBAC -> 004E4800: mark(x480) = 0
		@0018FBBC -> 004E0E00: mark(xe0) = 0
		@0018FC38 -> 004E3FC0: mark(x3fc) = 0
		@0018FCB4 -> 004E3F80: mark(x3f8) = 16777216
marking tls range from 004E0FD0 to 004E0FF0
		@004E0FD4 -> 004E0F80: mark(xf8) = 0
not skipping 004E0FB0, biti = 1009, at 004E0FC4
		@004E0FC4 -> 004E0FB0: mark(xf8) = 16777216
marking tls hp range from 0045AACC to 0045AB1C, base 005E37C8
Mark call for 1 005E37D8 with type info TypeInfo_AssociativeArray: rtInfo: has 1 pointers
Mark call for 1 005E37E8 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005E37F8 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005E3808 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005E380C with type info core.thread.Thread: class reference
		@005E380C -> 004E0F80: mark(xf8) = 16777216
Mark call for 1 005E3828 with type info core.thread.Fiber: class reference
Mark call for 1 005E3838 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005E383C with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005E3840 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 005E3848 with type info std.file.DirIteratorImpl: mark with rtInfo
	scan roots[]
	scan ranges[]
	mark hasPointer area
marking hp range from 0045A760 to 0045AA20
Mark call for 1 00441C60 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00441D60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DD0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441ED0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00442100 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442104 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442108 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044210C with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442110 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ABD0 with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABDC with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABE8 with type info std.stdio.File: mark with rtInfo
Mark call for 1 00443200 with type info TypeInfo_StaticArray: rtInfo: has 46 pointers
Mark call for 1 0045AC10 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC30 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AC40 with type info rt.dmain2.CArgs: mark with rtInfo
Mark call for 1 0045AC50 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC60 with type info gc.gc.GC: class reference
Mark call for 1 0045AC70 with type info gc.proxy.Proxy: mark with rtInfo
Mark call for 1 0045ACCC with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ACD0 with type info rt.sections_win32.SectionGroup: mark with rtInfo
Mark call for 1 0045AD00 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AD14 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00446028 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00446110 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 004461F0 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446280 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446460 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0044646C with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 00446478 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0045AD54 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD58 with type info gc.gc.GCMutex: class reference
Mark call for 1 0045AD90 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD94 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADB0 with type info rt.critical_.D_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE40 with type info core.sys.windows.windows._RTL_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE6C with type info core.thread.Thread: class reference
		@0045AE6C -> 004E0F80: mark(xf8) = 16777216
Mark call for 1 0045AEC0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
		@0045AEC0 -> 004E0FB0: mark(xf8) = 16777216
Mark call for 1 0045AEC8 with type info core.thread.Thread: class reference
		@0045AEC8 -> 004E0F80: mark(xf8) = 16777216
Mark call for 1 0045AEE0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00448320 with type info std.datetime.UTC: rtInfo: has 1 pointers
Mark call for 1 00448A90 with type info std.datetime.LocalTime: rtInfo: has 1 pointers
Mark call for 1 0045AFA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B130 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044B1A0 with type info TypeInfo_StaticArray: mark with rtInfo
Mark call for 1 0045B180 with type info core.sys.windows.dbghelp.DbgHelp: mark with rtInfo
Mark call for 1 0045B1C0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B2A0 with type info TypeInfo_Aya: mark with rtInfo
Mark call for 1 0044F870 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00450660 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00452730 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00453B30 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 0045C7D0 with type info std.file.DirIteratorImpl: rtInfo: has 22 pointers
Mark call for 1 00456810 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00457A20 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00458C30 with type info std.uni.Trie!(BitPacked!(bool, 1), dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(8u, 13u), sliceBits!(0u, 8u)).Trie: rtInfo: has 8 pointers
	scan heap
	free'ing
	collecting 004E0E80
	collecting 004E0F00
	collecting 004E1FB0
	collecting 004E1FC0
	collecting 004E1FD0
	collecting 004E1FE0
	collecting 004E1FF0
	collecting 004E2FA0
	collecting 004E2FC0
	collecting 004E2FE0
	collecting 004E3EC0
	collecting 004E3F00
	collecting 004E3F40
	collecting 004E4C00
	collecting 004E5F00
	collecting 004E6E00
	free complete pages
	recovered pages = 3
	free'd 2416 bytes, 0 pages from 1 pools
Minimizing.
Done minimizing.
Pool 006D0578:  256 really free, 256 supposedly free
Pool 006D0578:  255 really free, 255 supposedly free
Got large alloc:  02070000, pt = 8, np = 1
	malloc => 02070000
Emplacing TypeInfo_a at 02070010 + 4080
Setting a pointer bitmap for TypeInfo_a at 02070010 + 4080
	Compiler generated rtInfo: no pointers
Gcx.fullcollect()
Set bits
Marked free entries.
	scan roots[]
	scan ranges[]
	mark hasPointer area
marking hp range from 0045A760 to 0045AA20
Mark call for 1 00441C60 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00441D60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441D90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DD0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441DF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441E90 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EA0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EB0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EC0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441ED0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EE0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441EF0 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F00 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F10 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F20 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F30 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F40 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F50 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F60 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F70 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00441F80 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00442100 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442104 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442108 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044210C with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00442110 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ABD0 with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABDC with type info std.stdio.File: mark with rtInfo
Mark call for 1 0045ABE8 with type info std.stdio.File: mark with rtInfo
Mark call for 1 00443200 with type info TypeInfo_StaticArray: rtInfo: has 46 pointers
Mark call for 1 0045AC10 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC30 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AC40 with type info rt.dmain2.CArgs: mark with rtInfo
not skipping 005EC950, biti = 1, at 0045AC44
Mark call for 1 0045AC50 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AC60 with type info gc.gc.GC: class reference
Mark call for 1 0045AC70 with type info gc.proxy.Proxy: mark with rtInfo
Mark call for 1 0045ACCC with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ACD0 with type info rt.sections_win32.SectionGroup: mark with rtInfo
Mark call for 1 0045AD00 with type info TypeInfo_Array: mark with rtInfo
Mark call for 1 0045AD14 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00446028 with type info TypeInfo_Aya: rtInfo: has 2 pointers
Mark call for 1 00446110 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 004461F0 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446280 with type info TypeInfo_StaticArray: rtInfo: has 24 pointers
Mark call for 1 00446460 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0044646C with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 00446478 with type info std.stdio.File.Impl: mark with rtInfo
Mark call for 1 0045AD54 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD58 with type info gc.gc.GCMutex: class reference
Mark call for 1 0045AD90 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045AD94 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045ADB0 with type info rt.critical_.D_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE40 with type info core.sys.windows.windows._RTL_CRITICAL_SECTION: mark with rtInfo
Mark call for 1 0045AE6C with type info core.thread.Thread: class reference
		@0045AE6C -> 004E0F80: mark(xf8) = 0
not skipping 004E0FB0, biti = 1009, at 004E0FC4
		@004E0FC4 -> 004E0FB0: mark(xf8) = 16777216
not skipping 00622458, biti = 1011, at 004E0FCC
Mark call for 1 0045AEC0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
		@0045AEC0 -> 004E0FB0: mark(xf8) = 16777216
Mark call for 1 0045AEC8 with type info core.thread.Thread: class reference
		@0045AEC8 -> 004E0F80: mark(xf8) = 16777216
Mark call for 1 0045AEE0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 00448320 with type info std.datetime.UTC: rtInfo: has 1 pointers
Mark call for 1 00448A90 with type info std.datetime.LocalTime: rtInfo: has 1 pointers
Mark call for 1 0045AFA0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B130 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0044B1A0 with type info TypeInfo_StaticArray: mark with rtInfo
Mark call for 1 0045B180 with type info core.sys.windows.dbghelp.DbgHelp: mark with rtInfo
Mark call for 1 0045B1C0 with type info TypeInfo_Pointer: rtInfo: has 1 pointers
Mark call for 1 0045B2A0 with type info TypeInfo_Aya: mark with rtInfo
Mark call for 1 0044F870 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00450660 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00452730 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00453B30 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 0045C7D0 with type info std.file.DirIteratorImpl: rtInfo: has 22 pointers
Mark call for 1 00456810 with type info std.uni.Trie!(ushort, dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(6u, 13u), sliceBits!(0u, 6u)).Trie: rtInfo: has 8 pointers
Mark call for 1 00457A20 with type info TypeInfo_Array: rtInfo: has 2 pointers
Mark call for 1 00458C30 with type info std.uni.Trie!(BitPacked!(bool, 1), dchar, 1114112u, sliceBits!(13u, 21u), sliceBits!(8u, 13u), sliceBits!(0u, 8u)).Trie: rtInfo: has 8 pointers
	scan heap
	free'ing
	collecting 004E0E00
	collecting 004E2F80
	collecting 004E3F80
	collecting 004E3FC0
	collecting 004E4800
	collecting big 02070000
	free complete pages
	recovered pages = 3
	free'd 1312 bytes, 1 pages from 2 pools
